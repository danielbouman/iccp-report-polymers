\section{Introduction}
To study the behaviour of monopolymers of different lengths at various temperatures a simulation is written in Python and Fortran. The model for the polymers in is based on approximating the interaction between the monomers with a Lennard-Jones potential and a bending energy between adjacent monomers. By assuming the polymers are in a dilute solution, polymer-polymer self-interactions will prevail. This means that to extract data of the behaviour of the polymers, creating an ensemble of individual polymers will be sufficient.

The interaction between the beads is modelled by a Lennard-Jones (LJ) potential (Eq. \ref{eq:lj}, which represents a Van der Waals attraction at larger distances and repulsion at smaller distances, and a bending energy (Eq. \ref{eq:bending_energy}), which simulates the semi-flexibility of polymers.
\begin{equation}\label{eq:lj}
    V_{LJ} = 4\epsilon \left[ \left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^{6} \right],
\end{equation} where $\epsilon$ is the depth of the potential well, $\sigma$ is the finite distance where the potential is zero and $r$ is the distance between two particles. The parameters chosen for the LJ potential are $\epsilon=0.25$ and $\sigma=0.8$ \cite{jmt}.
\begin{equation}\label{eq:bending_energy}
    \epsilon_b(1-\cos{\theta}),
\end{equation} where $\epsilon_b\geq 0$ is the bending energy strength and $\theta$ is the angle between the new and preceding bead \cite{hsu2011review}.

\subsection{Markov chain}
For a canonical ensemble the probability of a given state $X$ is proportional to the Boltzmann weight, $P(\alpha) \propto e^{-\beta E(\alpha)}$. Here $\beta=1/\left(k_B T\right)$, where $k_B$ is the Boltzmann constant, $T$ the temperature and $E(X)$ the energy of a state $\alpha$. However, for states which have high $E$ the probabilities $P$ become vanishingly small. For computational reasons then, a bias for lower energies should be implemented when generating configurations.\todo[inline]{This is too ambiguous}

For polymers, it is natural to generate configurations on a per monomer basis. The energy gained by adding a monomer is dependent only on previously placed monomers. This means we can model the system as a Markov chain. The Rosenbluth and Rosenbluth (RR) algorithm is based on this process.


Average quantities in the 

\subsection{Monte carlo}

\subsection{Roulette-wheel algorithm}
The roulette-wheel algorithm, also known as fitness proportionate selection, is a method to select a member $j$ from a population with $N$ members, with a certain probability $p_j$. This is done by dividing the interval $[0,1]$ into $N$ segments of size $p_j$. Then a uniform random number is generated in that same interval. A member is selected by checking in which interval the random number lies.


\subsection{Rosenbluth and Rosenbluth algorithm}
In $d$ dimensions, if the distance between each monomer is set to 1, the amount of possible new monomer positions $N_{\theta}$ are positioned on a ($d$-1)-sphere of unit radius, with the last monomer as the centre.